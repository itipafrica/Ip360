import {
  Supercluster
} from "./chunk-OB6P6576.js";
import {
  require_react
} from "./chunk-AV2VUBUC.js";
import {
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/use-supercluster/dist/use-supercluster.esm.js
var import_react = __toESM(require_react());

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
var React = __toESM(require_react());

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
function useDeepCompareMemoize(value) {
  var ref = React.useRef(value);
  var signalRef = React.useRef(0);
  if (!dequal(value, ref.current)) {
    ref.current = value;
    signalRef.current += 1;
  }
  return React.useMemo(function() {
    return ref.current;
  }, [signalRef.current]);
}
function useDeepCompareEffectNoCheck(callback, dependencies) {
  return React.useEffect(callback, useDeepCompareMemoize(dependencies));
}

// node_modules/use-supercluster/dist/use-supercluster.esm.js
var useSupercluster = function useSupercluster2(_ref) {
  var points = _ref.points, bounds = _ref.bounds, zoom = _ref.zoom, options = _ref.options, disableRefresh = _ref.disableRefresh;
  var superclusterRef = (0, import_react.useRef)();
  var pointsRef = (0, import_react.useRef)();
  var _useState = (0, import_react.useState)([]), clusters = _useState[0], setClusters = _useState[1];
  var zoomInt = Math.round(zoom);
  useDeepCompareEffectNoCheck(function() {
    if (disableRefresh === true) {
      return;
    }
    if (!superclusterRef.current || !dequal(pointsRef.current, points) || !dequal(superclusterRef.current.options, options)) {
      superclusterRef.current = new Supercluster(options);
      superclusterRef.current.load(points);
    }
    if (bounds) {
      setClusters(superclusterRef.current.getClusters(bounds, zoomInt));
    }
    pointsRef.current = points;
  }, [points, bounds, zoomInt, options, disableRefresh]);
  return {
    clusters,
    supercluster: superclusterRef.current
  };
};
var use_supercluster_esm_default = useSupercluster;
export {
  use_supercluster_esm_default as default
};
//# sourceMappingURL=use-supercluster.js.map
